File Path: ./context.sh
Content:
find . -type d \( -path './bin' -o -path './.dart_tool' -o -path './.git' \) -prune -o \( -name '.gitignore' -prune \) -o -type f -print | xargs -I{} sh -c 'echo "File Path: {}" >> all_files_content.txt; echo "Content:" >> all_files_content.txt; cat "{}" >> all_files_content.txt; echo "" >> all_files_content.txt;'

File Path: ./test/shroom_test.dart
Content:
import 'package:shroom/shroom.dart';
import 'package:test/test.dart';

void main() {
  test('calculate', () {
    expect(calculate(), 42);
  });
}

File Path: ./test/src/models/tree_test.dart
Content:
import 'package:test/test.dart';
import '../../../lib/src/models/tree.dart';
import '../../../lib/src/sql/db.dart';
import 'dart:io';

const String schemaFilePath = 'lib/src/sql/schema.sql';
final String databaseFilePath = 'lib/src/test_database' + DateTime.now().toString() + '.db';

void main() {
  group('Tree Tests', () {
    late DatabaseManager dbManager;

    setUp(() {
      // Setup code before each test, if needed.
      dbManager = DatabaseManager(
        schemaFilePath: schemaFilePath,
        databaseFilePath: databaseFilePath,
      );
      dbManager.initDatabase();
      Tree.setDB(dbManager.getDatabase());
    });

    test('Tree Initialization', () {
      // Test the initialization of the Tree object.
      // Test saving a Tree object to the database.
      final tree = Tree('Pine');

      final db = dbManager.getDatabase();
      final sql = 'SELECT Name FROM Trees WHERE TreeID = ?';
      final stmt = db.prepare(sql);
      final result = stmt.select([tree.id]);
      expect(result.isNotEmpty, true);
      expect(result.first['Name'], 'Pine');
      stmt.dispose();
      db.dispose();
    });

    test('Tree Delete', ()  {
      // Test deleting a Tree object from the database.
      final tree = Tree('Maple');
      

      tree.delete();

      final db = dbManager.getDatabase();
      final sql = 'SELECT Name FROM Trees WHERE TreeID = ?';
      final stmt = db.prepare(sql);
      final result = stmt.select([tree.id]);
      expect(result.isEmpty, true);
      stmt.dispose();
      db.dispose();
    });

    test('Tree Should NOT Delete With Leaves', ()  {
      // Test that a Tree object with leaves cannot be deleted.
      final tree = Tree('Birch');
      

      // Add a leaf to the tree
      final leafSql = 'INSERT INTO Leaves (TreeID, ValueType, StringValue) VALUES (?, ?, ?)';
      final leafStmt = dbManager.getDatabase().prepare(leafSql);
      leafStmt.execute([tree.id, 'string', 'LeafValue']);
      leafStmt.dispose();

      // Attempt to delete the tree
      tree.delete();

      // Check if the tree still exists
      final db = dbManager.getDatabase();
      final checkSql = 'SELECT Name FROM Trees WHERE TreeID = ?';
      final checkStmt = db.prepare(checkSql);
      final checkResult = checkStmt.select([tree.id]);
      expect(checkResult.isNotEmpty, true);
      checkStmt.dispose();

      // Clean up
      final deleteLeafSql = 'DELETE FROM Leaves WHERE TreeID = ?';
      final deleteLeafStmt = db.prepare(deleteLeafSql);
      deleteLeafStmt.execute([tree.id]);
      deleteLeafStmt.dispose();
    });

    test('Get Tree By ID', () {
      // Test retrieving a Tree object by ID.
      final tree = Tree('Willow');
      

      final retrievedTree = Tree.getTreeById(tree.id!);
      expect(retrievedTree, isNotNull);
      expect(retrievedTree!.name, 'Willow');
    });

    tearDown(() {
      // Teardown code after each test, if needed.
      dbManager.removeDatabase();
    });
  });
}

File Path: ./test/src/models/mushroom_test.dart
Content:
import 'package:test/test.dart';
import '../../../lib/src/models/mushroom.dart';
import '../../../lib/src/models/leaf.dart';
import '../../../lib/src/models/tree.dart';
import '../../../lib/src/sql/db.dart';
import 'dart:io';

const String schemaFilePath = 'lib/src/sql/schema.sql';
final String databaseFilePath = 'lib/src/test_database' + DateTime.now().toString() + '.db';

void main() {
  group('Mushroom Tests', () {
    late DatabaseManager dbManager;

    setUp(() {
      // Setup code before each test
      dbManager = DatabaseManager(
        schemaFilePath: schemaFilePath,
        databaseFilePath: databaseFilePath,
      );
      dbManager.initDatabase();
      Tree.setDB(dbManager.getDatabase());
      Leaf.setDB(dbManager.getDatabase());
      Mushroom.setDB(dbManager.getDatabase());
    });

    test('Mushroom Initialization', () {
      // Test the initialization of the Mushroom object
      final tree1 = Tree('Oak');
      final tree2 = Tree('Pine');

      final leaf1 = Leaf(tree: tree1, valueType: 'int', value: 10);
      final leaf2 = Leaf(tree: tree2, valueType: 'string', value: 'Green');

      final mushroom = Mushroom([leaf1, leaf2]);

      expect(mushroom.leaves.length, 2);
      expect(mushroom.leaves[0].value, 10);
      expect(mushroom.leaves[1].value, 'Green');
    });

    test('Mushroom Delete', () async {
  // Test deleting a Mushroom object from the database
  final tree1 = Tree('Willow');
  final tree2 = Tree('Redwood');
  final leaf1 = Leaf(tree: tree1, valueType: 'int', value: 15);
  final leaf2 = Leaf(tree: tree2, valueType: 'string', value: 'Yellow');
  final mushroom = Mushroom([leaf1, leaf2]);
   
  for(var i in mushroom.leaves){
    print(i.tree.id);
  }

  // Delete the mushroom
   mushroom.delete();

  // Check if the mushroom has been deleted
  final db = dbManager.getDatabase();
  final mushroomSql = 'SELECT MushroomID FROM Mushrooms WHERE MushroomID = ?';
  final mushroomStmt = db.prepare(mushroomSql);
  final mushroomResult = mushroomStmt.select([mushroom.id]);
  expect(mushroomResult.isEmpty, true);
  mushroomStmt.dispose();

  // Check if the leaves have been deleted
  final leafSql = 'SELECT LeafID FROM Leaves WHERE LeafID = ? OR LeafID = ?';
  final leafStmt = db.prepare(leafSql);
  final leafResult = leafStmt.select([leaf1.id, leaf2.id]);
  print(leafResult);
  expect(leafResult.isEmpty, true);
//   leafStmt.dispose();

//   db.dispose();
});


    tearDown(() {
      // Teardown code after each test
      dbManager.removeDatabase();
    });
  });
}

File Path: ./test/src/models/leaf_test.dart
Content:
import 'package:test/test.dart';
import '../../../lib/src/models/leaf.dart';
import '../../../lib/src/models/tree.dart';
import '../../../lib/src/sql/db.dart';
import 'dart:io';

const String schemaFilePath = 'lib/src/sql/schema.sql';
final String databaseFilePath = 'lib/src/test_database' + DateTime.now().toString() + '.db';

void main() {
  group('Leaf Tests', () {
    late DatabaseManager dbManager;

    setUp(() {
      // Setup code before each test
      dbManager = DatabaseManager(
        schemaFilePath: schemaFilePath,
        databaseFilePath: databaseFilePath,
      );
      dbManager.initDatabase();
      Tree.setDB(dbManager.getDatabase());
      Leaf.setDB(dbManager.getDatabase());
      // Mushroom.setDB(dbManager.getDatabase());
    });

    test('Leaf Initialization - String', () {
      // Test the initialization of the Leaf object
      final tree = Tree('Maple');
      final leaf = Leaf(tree: tree, valueType: 'string', value: 'Green');
      expect(leaf.tree.name, 'Maple');
      expect(leaf.valueType, 'string');
      expect(leaf.value, 'Green');
    });

    test('Leaf Initialization - Int', () {
      // Test the initialization of the Leaf object
      final tree = Tree('Maple');
      final leaf = Leaf(tree: tree, valueType: 'int', value:42);
      expect(leaf.tree.name, 'Maple');
      expect(leaf.valueType, 'int');
      expect(leaf.value, 42);
    });

    test('Leaf Initialization - Float', () {

      // Test the initialization of the Leaf object
      final tree = Tree('Maple');
      final leaf = Leaf(tree: tree, valueType: 'float', value:42.555);
      expect(leaf.tree.name, 'Maple');
      expect(leaf.valueType, 'float');
      expect(leaf.value, 42.555);
    });

    test('Leaf Initialization - Binary', () {
      // Setup a tree for the leaf
      final tree = Tree('Cedar');


      // Create a binary data array
      List<int> binaryData = [0, 255, 127, 128];

      // Initialize the leaf with binary data
      final leaf = Leaf(tree: tree, valueType: 'binary', value: binaryData);

      // Save the leaf to the database
      

      // Fetch the leaf from the database to verify it was saved correctly
      final db = dbManager.getDatabase();
      final sql = 'SELECT TreeID, ValueType, BinaryValue FROM Leaves WHERE LeafID = ?';
      final stmt = db.prepare(sql);
      final result = stmt.select([leaf.id]);

      // Check that the database entry matches the input
      expect(result.isNotEmpty, true);
      expect(result.first['TreeID'], tree.id);
      expect(result.first['ValueType'], 'binary');
      expect(result.first['BinaryValue'], binaryData);
    });

  test('Leaf Initialization - Spell', () {
    // Setup a tree for the leaf
    final tree = Tree('Birch');


    // Initialize the leaf with a spell type
    final spellDescription = 'Invisibility';
    final leaf = Leaf(tree: tree, valueType: 'spell', value: spellDescription);



    // Fetch the leaf from the database to verify it was saved correctly
    final db = dbManager.getDatabase();
    final sql = 'SELECT TreeID, ValueType, SpellValue FROM Leaves WHERE LeafID = ?';
    final stmt = db.prepare(sql);
    final result = stmt.select([leaf.id]);

    // Check that the database entry matches the input
    expect(result.isNotEmpty, true);
    expect(result.first['TreeID'], tree.id);
    expect(result.first['ValueType'], 'spell');
    expect(result.first['SpellValue'], spellDescription);

    // Clean up
    stmt.dispose();
    db.dispose();
  });

  test('Leaf Initialization - Mushroom', () {
    // Setup a tree for the leaf
    final tree = Tree('Elm');


    // Example Mushroom ID
    final exampleMushroomId = 1;

    // Initialize the leaf with a mushroom type
    final leaf = Leaf(tree: tree, valueType: 'mushroom', value: exampleMushroomId);



    // Fetch the leaf from the database to verify it was saved correctly
    final db = dbManager.getDatabase();
    final sql = 'SELECT TreeID, ValueType, MushroomValue FROM Leaves WHERE LeafID = ?';
    final stmt = db.prepare(sql);
    final result = stmt.select([leaf.id]);

    // Check that the database entry matches the input
    expect(result.isNotEmpty, true);
    expect(result.first['TreeID'], tree.id);
    expect(result.first['ValueType'], 'mushroom');
    expect(result.first['MushroomValue'], exampleMushroomId);

    // Clean up
    stmt.dispose();
    db.dispose();
  });



    //TESTED IN INITIALIZATION
    // test('Leaf Save', () {
    //   // Test saving a Leaf object to the database
    //   final tree = Tree('Birch');
    // //   tree.save();
    //   final leaf = Leaf(tree: tree, valueType: 'int', value: 42);
    //   

    //   final db = dbManager.getDatabase();
    //   final sql = 'SELECT TreeID, ValueType, IntValue FROM Leaves WHERE LeafID = ?';
    //   final stmt = db.prepare(sql);
    //   final result = stmt.select([leaf.id]);
    //   expect(result.isNotEmpty, true);
    //   expect(result.first['TreeID'], tree.id);
    //   expect(result.first['ValueType'], 'int');
    //   expect(result.first['IntValue'], 42);
    //   stmt.dispose();
    //   db.dispose();
    // });

    test('Leaf Delete', () {
      // Test that a Leaf object without an associated mushroom can be deleted
      final tree = Tree('Willow');
      final leaf = Leaf(tree: tree, valueType: 'string', value: 'Yellow');
      

      // Attempt to delete the leaf
      leaf.delete();

      // Check if the leaf has been deleted
      final db = dbManager.getDatabase();
      final checkSql = 'SELECT ValueType, StringValue FROM Leaves WHERE LeafID = ?';
      final checkStmt = db.prepare(checkSql);
      final checkResult = checkStmt.select([leaf.id]);
      print(checkResult.toString());
      expect(checkResult.isEmpty, true);
      checkStmt.dispose();
    });

    tearDown(() {
      // Teardown code after each test
      dbManager.removeDatabase();
    });
  });
}

File Path: ./test/src/sql/db_test.dart
Content:
import 'package:test/test.dart';
import '../../../lib/src/sql/db.dart';
import 'dart:io';

const String schemaFilePath = 'lib/src/sql/schema.sql';
final String databaseFilePath = 'lib/src/test_database' + DateTime.now().toString() + '.db';

void main() {
  group('DatabaseManager Tests', () {
    late DatabaseManager dbManager;

    setUp(() {
      // Setup code before each test
      dbManager = DatabaseManager(
        schemaFilePath: schemaFilePath,
        databaseFilePath: databaseFilePath,
      );
    });
// THIS IS INCLUDED IN GET DATABASE TEST
    test('Database Initialization', () {
      // Test the initialization of the database
      dbManager.initDatabase();
      final dbFile = File(dbManager.databaseFilePath);
      expect(dbFile.existsSync(), true);
    });

    test('Get Database', () {
      // Test getting the database
      final db = dbManager.getDatabase();
      expect(db, isNotNull);
      db.dispose();
      dbManager.removeDatabase();
    });

    test('Remove Database', () {
      // Test removing the database
      dbManager.getDatabase();
      dbManager.removeDatabase();
      final dbFile = File(dbManager.databaseFilePath);
      expect(dbFile.existsSync(), false);
    });

    tearDown(() {
      // Teardown code after each test
      // dbManager.removeDatabase();
    });
  });
}

File Path: ./CHANGELOG.md
Content:
## 1.0.0

- Initial version.

File Path: ./pubspec.lock
Content:
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: "0b2f2bd91ba804e53a61d757b986f89f1f9eaed5b11e4b2f5a2468d86d6c9fc7"
      url: "https://pub.dev"
    source: hosted
    version: "67.0.0"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: "37577842a27e4338429a1cbc32679d508836510b056f1eedf0c8d20e39c1383d"
      url: "https://pub.dev"
    source: hosted
    version: "6.4.1"
  args:
    dependency: transitive
    description:
      name: args
      sha256: "7cf60b9f0cc88203c5a190b4cd62a99feea42759a7fa695010eb5de1c0b2252a"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "947bfcf187f74dbc5e146c9eb9c0f10c9f8b30743e341481c1e2ed3ecc18c20c"
      url: "https://pub.dev"
    source: hosted
    version: "2.11.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "6cfb5af12253eaf2b368f07bacc5a80d1301a071c73360d746b7f2e32d762c66"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: ee67cb0715911d28db6bf4af1026078bd6f0128b07a5f66fb2ed94ec6783c09a
      url: "https://pub.dev"
    source: hosted
    version: "1.18.0"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: "0f08b14755d163f6e2134cb58222dd25ea2a2ee8a195e53983d57c075324d592"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.1"
  coverage:
    dependency: transitive
    description:
      name: coverage
      sha256: "8acabb8306b57a409bf4c83522065672ee13179297a6bb0cb9ead73948df7c76"
      url: "https://pub.dev"
    source: hosted
    version: "1.7.2"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: ff625774173754681d66daaf4a448684fb04b78f902da9cb3d308c19cc5e8bab
      url: "https://pub.dev"
    source: hosted
    version: "3.0.3"
  ffi:
    dependency: transitive
    description:
      name: ffi
      sha256: "493f37e7df1804778ff3a53bd691d8692ddf69702cf4c1c1096a2e41b4779e21"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  file:
    dependency: transitive
    description:
      name: file
      sha256: "5fc22d7c25582e38ad9a8515372cd9a93834027aacf1801cf01164dac0ffa08c"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.0"
  frontend_server_client:
    dependency: transitive
    description:
      name: frontend_server_client
      sha256: f64a0333a82f30b0cca061bc3d143813a486dc086b574bfb233b7c1372427694
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: "0e7014b3b7d4dac1ca4d6114f82bf1782ee86745b9b42a92c9289c23d8a0ab63"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  http_multi_server:
    dependency: transitive
    description:
      name: http_multi_server
      sha256: "97486f20f9c2f7be8f514851703d0119c3596d14ea63227af6f7a481ef2b2f8b"
      url: "https://pub.dev"
    source: hosted
    version: "3.2.1"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "2aa08ce0341cc9b354a498388e30986515406668dbcc4f7c950c3e715496693b"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.2"
  io:
    dependency: transitive
    description:
      name: io
      sha256: "2ec25704aba361659e10e3e5f5d672068d332fc8ac516421d483a11e5cbd061e"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.4"
  js:
    dependency: transitive
    description:
      name: js
      sha256: c1b2e9b5ea78c45e1a0788d29606ba27dc5f71f019f32ca5140f61ef071838cf
      url: "https://pub.dev"
    source: hosted
    version: "0.7.1"
  lints:
    dependency: "direct dev"
    description:
      name: lints
      sha256: cbf8d4b858bb0134ef3ef87841abdf8d63bfc255c266b7bf6b39daa1085c4290
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: "623a88c9594aa774443aa3eb2d41807a48486b5613e67599fb4c41c0ad47c340"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: d2323aa2060500f906aa31a895b4030b6da3ebdcc5619d14ce1aada65cd161cb
      url: "https://pub.dev"
    source: hosted
    version: "0.12.16+1"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: "25dfcaf170a0190f47ca6355bdd4552cb8924b430512ff0cafb8db9bd41fe33b"
      url: "https://pub.dev"
    source: hosted
    version: "1.14.0"
  mime:
    dependency: transitive
    description:
      name: mime
      sha256: "2e123074287cc9fd6c09de8336dae606d1ddb88d9ac47358826db698c176a1f2"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.5"
  node_preamble:
    dependency: transitive
    description:
      name: node_preamble
      sha256: "6e7eac89047ab8a8d26cf16127b5ed26de65209847630400f9aefd7cd5c730db"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.2"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: "1c5b77ccc91e4823a5af61ee74e6b972db1ef98c2ff5a18d3161c982a55448bd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  path:
    dependency: "direct main"
    description:
      name: path
      sha256: "087ce49c3f0dc39180befefc60fdb4acd8f8620e5682fe2476afd0b3688bb4af"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.0"
  pool:
    dependency: transitive
    description:
      name: pool
      sha256: "20fe868b6314b322ea036ba325e6fc0711a22948856475e2c2b6306e8ab39c2a"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.1"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "40d3ab1bbd474c4c2328c91e3a7df8c6dd629b79ece4c4bd04bee496a224fb0c"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  shelf:
    dependency: transitive
    description:
      name: shelf
      sha256: ad29c505aee705f41a4d8963641f91ac4cee3c8fad5947e033390a7bd8180fa4
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  shelf_packages_handler:
    dependency: transitive
    description:
      name: shelf_packages_handler
      sha256: "89f967eca29607c933ba9571d838be31d67f53f6e4ee15147d5dc2934fee1b1e"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.2"
  shelf_static:
    dependency: transitive
    description:
      name: shelf_static
      sha256: a41d3f53c4adf0f57480578c1d61d90342cd617de7fc8077b1304643c2d85c1e
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  shelf_web_socket:
    dependency: transitive
    description:
      name: shelf_web_socket
      sha256: "9ca081be41c60190ebcb4766b2486a7d50261db7bd0f5d9615f2d653637a84c1"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.4"
  source_map_stack_trace:
    dependency: transitive
    description:
      name: source_map_stack_trace
      sha256: "84cf769ad83aa6bb61e0aa5a18e53aea683395f196a6f39c4c881fb90ed4f7ae"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  source_maps:
    dependency: transitive
    description:
      name: source_maps
      sha256: "708b3f6b97248e5781f493b765c3337db11c5d2c81c3094f10904bfa8004c703"
      url: "https://pub.dev"
    source: hosted
    version: "0.10.12"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "53e943d4206a5e30df338fd4c6e7a077e02254531b138a15aec3bd143c1a8b3c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.0"
  sqlite3:
    dependency: "direct main"
    description:
      name: sqlite3
      sha256: "1abbeb84bf2b1a10e5e1138c913123c8aa9d83cd64e5f9a0dd847b3c83063202"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "73713990125a6d93122541237550ee3352a2d84baad52d375a4cad2eb9b7ce0b"
      url: "https://pub.dev"
    source: hosted
    version: "1.11.1"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: ba2aa5d8cc609d96bbb2899c28934f9e1af5cddbd60a827822ea467161eb54e7
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "556692adab6cfa87322a115640c11f13cb77b3f076ddcc5d6ae3c20242bedcde"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: a29248a84fbb7c79282b40b8c72a1209db169a2e0542bce341da992fe1bc7e84
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  test:
    dependency: "direct dev"
    description:
      name: test
      sha256: d72b538180efcf8413cd2e4e6fcc7ae99c7712e0909eb9223f9da6e6d0ef715f
      url: "https://pub.dev"
    source: hosted
    version: "1.25.4"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: "2419f20b0c8677b2d67c8ac4d1ac7372d862dc6c460cdbb052b40155408cd794"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.1"
  test_core:
    dependency: transitive
    description:
      name: test_core
      sha256: "4d070a6bc36c1c4e89f20d353bfd71dc30cdf2bd0e14349090af360a029ab292"
      url: "https://pub.dev"
    source: hosted
    version: "0.6.2"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: facc8d6582f16042dd49f2463ff1bd6e2c9ef9f3d5da3d9b087e244a7b564b3c
      url: "https://pub.dev"
    source: hosted
    version: "1.3.2"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "3923c89304b715fb1eb6423f017651664a03bf5f4b29983627c4da791f74a4ec"
      url: "https://pub.dev"
    source: hosted
    version: "14.2.1"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: "3d2ad6751b3c16cf07c7fca317a1413b3f26530319181b37e3b9039b84fc01d8"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  web:
    dependency: transitive
    description:
      name: web
      sha256: "97da13628db363c635202ad97068d47c5b8aa555808e7a9411963c533b449b27"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.1"
  web_socket_channel:
    dependency: transitive
    description:
      name: web_socket_channel
      sha256: "58c6666b342a38816b2e7e50ed0f1e261959630becd4c879c4f26bfa14aa5a42"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.5"
  webkit_inspection_protocol:
    dependency: transitive
    description:
      name: webkit_inspection_protocol
      sha256: "87d3f2333bb240704cd3f1c6b5b7acd8a10e7f0bc28c28dcf14e782014f4a572"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: "75769501ea3489fca56601ff33454fe45507ea3bfb014161abc3b43ae25989d5"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
sdks:
  dart: ">=3.3.3 <4.0.0"

File Path: ./README.md
Content:
A sample command-line application with an entrypoint in `bin/`, library code
in `lib/`, and example unit test in `test/`.

File Path: ./pubspec.yaml
Content:
name: shroom
description: A sample command-line application.
version: 1.0.0
# repository: https://github.com/my_org/my_repo

environment:
  sdk: ^3.3.3

# Add regular dependencies here.
dependencies:
  path: ^1.8.0
  sqlite3: ^2.4.2

dev_dependencies:
  lints: ^3.0.0
  test: ^1.24.0

File Path: ./lib/shroom.dart
Content:
int calculate() {
  return 6 * 7;
}

File Path: ./lib/src/models/tree.dart
Content:
import 'package:sqlite3/sqlite3.dart';

class Tree {
  static Database? _db;
  String name;
  int? id;
  static String tableName = 'Trees';

  static void setDB(Database db) {
    _db = db;
  }

  Tree(this.name){
    _save();
  }



  void _checkAndCreateId() {
    if (_db == null) {
      throw Exception('Database not set.');
    }

    if (id == null) {
      final sql = 'SELECT TreeID FROM $tableName WHERE Name = ?';
      final stmt = _db!.prepare(sql);
      final result = stmt.select([name]);
      if (result.isNotEmpty) {
        id = result.first['TreeID'] as int?;
      } else {
        stmt.dispose();
        final insertSql = 'INSERT INTO $tableName (Name) VALUES (?)';
        final insertStmt = _db!.prepare(insertSql);
        insertStmt.execute([name]);
        id = _db!.lastInsertRowId;
        insertStmt.dispose();
      }
    }
  }

  void _save()  {
    _checkAndCreateId();
  }

  void delete()  {
    // Check if the tree still has leaves
    final sql = 'SELECT COUNT(*) FROM Leaves WHERE TreeID = ?';
    final stmt = _db!.prepare(sql);
    final result = stmt.select([id]);
    if (result.isNotEmpty && result.first['COUNT(*)'] as int > 0) {
    //   throw Exception('Tree still has leaves');
     return;
    }

    // Delete the tree
    final deleteSql = 'DELETE FROM $tableName WHERE TreeID = ?';
    final deleteStmt = _db!.prepare(deleteSql);
    deleteStmt.execute([id]);
    deleteStmt.dispose();
  }

  static Tree? getTreeById(int id) {
    final sql = 'SELECT Name FROM $tableName WHERE TreeID = ?';
    final stmt = _db!.prepare(sql);
    final result = stmt.select([id]);
    if (result.isNotEmpty) {
      return Tree(result.first['Name'] as String);
    }
    return null;
  }
}

File Path: ./lib/src/models/macroshroom.dart
Content:
import 'package:sqlite3/sqlite3.dart';
import 'mushroom.dart';
import 'leaf.dart';

class MacroShroom extends Mushroom {
  String name;
  static String tableName = 'MacroShroomNames';
  static Database? _db;
  static void setDB(Database db) {
    _db = db;
  }

  MacroShroom(this.name, List<Leaf> leaves) : super(leaves);

  @override
  void save() {
    super.save();
    if (_db == null) {
      throw Exception('Database not set.');
    }
    if (id == null) {
      throw Exception('MacroShroom ID not set.');
    }

    final insertSql = 'INSERT INTO $tableName (MushroomID, Name) VALUES (?, ?)';
    final insertStmt = _db!.prepare(insertSql);
    insertStmt.execute([id, name]);
    insertStmt.dispose();
  }

  @override
  void delete() {
    super.delete();
    if (_db == null) {
      throw Exception('Database not set.');
    }
    if (id == null) {
      throw Exception('MacroShroom ID not set.');
    }

    final deleteSql = 'DELETE FROM $tableName WHERE MushroomID = ?';
    final deleteStmt = _db!.prepare(deleteSql);
    deleteStmt.execute([id]);
    deleteStmt.dispose();
  }

}

File Path: ./lib/src/models/leaf.dart
Content:
import 'package:sqlite3/sqlite3.dart';
import 'tree.dart';

const List<String> valueTypes = ['int', 'float', 'string', 'mushroom', 'spell', 'binary'];

class Leaf {
  Tree tree;
  String valueType;
  dynamic value;
  int? id;
  static String tableName = 'Leaves';
  static Database? _db;

  Leaf({required this.tree, required this.valueType, this.value}) {
    if (!valueTypes.contains(valueType)) {
      throw ArgumentError('Invalid value type');
    }
    _save();

  }

  static Leaf getLeafById(int leafId) {
    if (_db == null) {
      throw Exception('Database not set.');
    }

    final sql = 'SELECT TreeID, ValueType, IntValue, FloatValue, StringValue, MushroomValue, SpellValue, BinaryValue FROM $tableName WHERE LeafID = ?';
    final stmt = _db!.prepare(sql);
    final result = stmt.select([leafId]);
    if (result.isNotEmpty) {
      final tree = Tree.getTreeById(result.first['TreeID'] as int);
      final valueType = result.first['ValueType'] as String;
      final value = result.first[valueType + 'Value'];
      return Leaf(tree: tree!, valueType: valueType, value: value);
    } else {
      throw Exception('Leaf not found');
    }
  }

  static void setDB(Database db) {
    _db = db;
  }

  void _checkAndCreateId() {
    if (_db == null) {
      throw Exception('Database not set.');
    }

    if (id == null) {
      final sql = 'SELECT LeafID FROM $tableName WHERE TreeID = ? AND ValueType = ?';
      final stmt = _db!.prepare(sql);
      final result = stmt.select([tree.id, valueType]);
      if (result.isNotEmpty) {
        id = result.first['LeafID'] as int?;
      } else {
        stmt.dispose();
        final insertSql = 'INSERT INTO $tableName (TreeID, ValueType) VALUES (?, ?)';
        final insertStmt = _db!.prepare(insertSql);
        insertStmt.execute([tree.id, valueType]);
        id = _db!.lastInsertRowId;
        insertStmt.dispose();
      }
    }
  }

  void _save()  {
    _checkAndCreateId();
    if (_db == null) {
      throw Exception('Database not set.');
    }
    if (id == null) {
      throw Exception('Leaf ID not set.');
    }

    final updateSql = '''
    UPDATE $tableName 
    SET IntValue = ?, 
        FloatValue = ?, 
        StringValue = ?, 
        MushroomValue = ?, 
        SpellValue = ?, 
        BinaryValue = ? 
    WHERE LeafID = ?''';
    final updateStmt = _db!.prepare(updateSql);

    updateStmt.execute([
      valueType == 'int' ? value : null,
      valueType == 'float' ? value : null,
      valueType == 'string' ? value : null,
      valueType == 'mushroom' ? value : null,
      valueType == 'spell' ? value : null,
      valueType == 'binary' ? value : null,
      id
    ]);

    updateStmt.dispose();
    return;
  }

  void delete()  {
  // //shoulf be deleted iff no mycelium associates
  //   final sql = 'SELECT COUNT(*) FROM Mycelium WHERE LeafID = ?';
  //   final stmt = _db!.prepare(sql);
  //   final result = stmt.select([id]);
  //   if (result.isNotEmpty) {
  //       if (result.first['COUNT(*)'] as int > 0) {
  //           // throw Exception('Leaf still has mycelium');
  //       } else {
            // Delete the leaf

            final deleteSql = 'DELETE FROM $tableName WHERE LeafID = ?';
            final deleteStmt = _db!.prepare(deleteSql);
            deleteStmt.execute([id]);
            deleteStmt.dispose();

            // print(this.tree.id);

            Tree treeObj = Tree.getTreeById(this.tree.id!)!;
            treeObj.delete();

            print('Leaf deleted'+id.toString());
    //     }
    // }
    return;
  }
}

File Path: ./lib/src/models/spell.dart
Content:
// File: lib/model/spell.dart
class Spell {
  String description;

  Spell(this.description);

  @override
  String toString() {
    return description;
  }
}

File Path: ./lib/src/models/mushroom.dart
Content:
import 'package:sqlite3/sqlite3.dart';
import 'leaf.dart';
import 'tree.dart';

class Mushroom {
  List<Leaf> leaves;
  int? id;
  static String tableName = 'Mushrooms';
  static Database? _db;

  Mushroom(this.leaves) {
    _checkLeavesFromDifferentTrees();
    save();
  }

  static void setDB(Database db) {
    _db = db;
  }

  void _checkLeavesFromDifferentTrees() {
    final treeNames = leaves.map((leaf) => leaf.tree.name).toSet();
    if (treeNames.length != leaves.length) {
      throw ArgumentError('One mushroom can only have one leaf from each tree.');
    }
  }

  void _checkAndCreateId() {
    if (_db == null) {
      throw Exception('Database not set.');
    }

    if (id == null) {
      final insertSql = 'INSERT INTO $tableName DEFAULT VALUES';
      final insertStmt = _db!.prepare(insertSql);
      insertStmt.execute();
      id = _db!.lastInsertRowId;
      insertStmt.dispose();
    }
  }

  Set<int> _getExistingLeafIds() {
    final existingLeavesQuery = 'SELECT LeafID FROM Mycelium WHERE MushroomID = ?';
    final existingLeavesStmt = _db!.prepare(existingLeavesQuery);
    final existingLeavesResult = existingLeavesStmt.select([id]);
    final existingLeafIds = existingLeavesResult.map((row) => row['LeafID'] as int).toSet();
    existingLeavesStmt.dispose();
    return existingLeafIds;
  }

  void _insertIntoMycelium(int leafId)  {
    final myceliumInsertSql = 'INSERT INTO Mycelium (MushroomID, LeafID) VALUES (?, ?)';
    final myceliumInsertStmt = _db!.prepare(myceliumInsertSql);
    myceliumInsertStmt.execute([id, leafId]);
    myceliumInsertStmt.dispose();
  }

  void _deleteFromMycelium(int leafId)  {
    final myceliumDeleteSql = 'DELETE FROM Mycelium WHERE MushroomID = ? AND LeafID = ?';
    final myceliumDeleteStmt = _db!.prepare(myceliumDeleteSql);
    myceliumDeleteStmt.execute([id, leafId]);
    myceliumDeleteStmt.dispose();
  }

  void save() {
    _checkAndCreateId();
    if (_db == null) {
      throw Exception('Database not set.');
    }
    if (id == null) {
      throw Exception('Mushroom ID not set.');
    }

    final existingLeafIds = _getExistingLeafIds();

    for (var leaf in leaves) {
      if (!existingLeafIds.contains(leaf.id)) {
        _insertIntoMycelium(leaf.id!);
      }
      existingLeafIds.remove(leaf.id);
    }

    for (var leafId in existingLeafIds) {
      _deleteFromMycelium(leafId);
      final leaf = Leaf.getLeafById(leafId);
       leaf.delete();
    }
  }

  void delete() {
    if (_db == null) {
      throw Exception('Database not set.');
    }
    if (id == null) {
      throw Exception('Mushroom ID not set.');
    }

    // Retrieve all leaves associated with this mushroom
    final myceliumQuery = 'SELECT LeafID FROM Mycelium WHERE MushroomID = ?';
    final myceliumStmt = _db!.prepare(myceliumQuery);
    final myceliumResult = myceliumStmt.select([id]);
    myceliumStmt.dispose();

    // Delete each leaf
    for (var row in myceliumResult) {
      final leafId = row['LeafID'] as int;
      final leaf = Leaf.getLeafById(leafId);
      leaf.delete();
    }

    // Delete all mycelium entries associated with this mushroom
    final myceliumDeleteSql = 'DELETE FROM Mycelium WHERE MushroomID = ?';
    final myceliumDeleteStmt = _db!.prepare(myceliumDeleteSql);
    myceliumDeleteStmt.execute([id]);
    myceliumDeleteStmt.dispose();

    // Delete the mushroom from the Mushrooms table
    final mushroomDeleteSql = 'DELETE FROM Mushrooms WHERE MushroomID = ?';
    final mushroomDeleteStmt = _db!.prepare(mushroomDeleteSql);
    mushroomDeleteStmt.execute([id]);
    mushroomDeleteStmt.dispose();
  }
}

File Path: ./lib/src/sql/schema.sql
Content:
CREATE TABLE Mushrooms (
    MushroomID INTEGER PRIMARY KEY
);

CREATE TABLE MacroShroomNames (
    MushroomID INTEGER PRIMARY KEY,
    Name TEXT UNIQUE,
    FOREIGN KEY (MushroomID) REFERENCES Mushrooms(MushroomID)
);

CREATE TABLE Trees (
    TreeID INTEGER PRIMARY KEY,
    Name TEXT UNIQUE
);

CREATE TABLE Leaves (
    LeafID INTEGER PRIMARY KEY,
    TreeID INTEGER,
    ValueType TEXT CHECK(ValueType IN ('int', 'float', 'string', 'mushroom', 'spell', 'binary')),
    IntValue INTEGER,
    FloatValue REAL,
    StringValue TEXT,
    MushroomValue INTEGER,
    SpellValue TEXT,
    BinaryValue BLOB,
    FOREIGN KEY (TreeID) REFERENCES Trees(TreeID),
    FOREIGN KEY (MushroomValue) REFERENCES Mushrooms(MushroomID)
);

CREATE TABLE Mycelium (
    MyceliumID INTEGER PRIMARY KEY,
    MushroomID INTEGER,
    LeafID INTEGER,
    FOREIGN KEY (MushroomID) REFERENCES Mushrooms(MushroomID),
    FOREIGN KEY (LeafID) REFERENCES Leaves(LeafID)
);

File Path: ./lib/src/sql/db.dart
Content:
import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:sqlite3/sqlite3.dart';

class DatabaseManager {
  final String schemaFilePath;
  final String databaseFilePath;
  late String dbPath;

  DatabaseManager({required this.schemaFilePath, required this.databaseFilePath}) {
    dbPath = databaseFilePath;
  }

  Database getDatabase() {
    final dbFile = File(dbPath);
    if (!dbFile.existsSync()) {
      initDatabase();
    }
    return sqlite3.open(dbPath);
  }

  void initDatabase() {
    final schema = _readSqlSchema(schemaFilePath);
    if (schema.isNotEmpty) {
      final dbFile = File(dbPath);
      if (!dbFile.existsSync()) {
        _initializeDatabase(schema, dbPath);
      } else {
        print('Database already exists. No action taken.');
      }
    }
  }

  void _initializeDatabase(String schema, String dbPath) {
    try {
      final db = sqlite3.open(dbPath);
      db.execute(schema);
      print('Database initialized successfully. Database file: $dbPath');
      db.dispose();
    } catch (e) {
      print('Error initializing database: $e');
    }
  }

  String _readSqlSchema(String filePath) {
    try {
      return File(filePath).readAsStringSync();
    } catch (e) {
      print('Error reading schema file: $e');
      return '';
    }
  }

  void removeDatabase() {
    final file = File(dbPath);
    if (file.existsSync()) {
      file.delete();
      print('Database removed successfully. Database file: $dbPath');
    } else {
      print('Database does not exist. No action taken.');
    }
  }

  /// Asynchronously deletes mushrooms that are not referenced in MacroShroomNames and not associated with any leaf in Mycelium.
  void prune() {
    final db = getDatabase();
    try {
      const sql = '''
        DELETE FROM Mushrooms
        WHERE MushroomID NOT IN (SELECT MushroomID FROM MacroShroomNames)
        AND MushroomID NOT IN (SELECT MushroomID FROM Mycelium);
      ''';
      db.execute(sql); // Using executeAsync if supported, or handle the async operation differently
      print('Pruning complete: Unreferenced mushrooms have been deleted.');
    } catch (e) {
      print('Error during pruning: $e');
    } finally {
      db.dispose();
    }
  }
}

File Path: ./analysis_options.yaml
Content:
# This file configures the static analysis results for your project (errors,
# warnings, and lints).
#
# This enables the 'recommended' set of lints from `package:lints`.
# This set helps identify many issues that may lead to problems when running
# or consuming Dart code, and enforces writing Dart using a single, idiomatic
# style and format.
#
# If you want a smaller set of lints you can change this to specify
# 'package:lints/core.yaml'. These are just the most critical lints
# (the recommended set includes the core lints).
# The core lints are also what is used by pub.dev for scoring packages.

include: package:lints/recommended.yaml

# Uncomment the following section to specify additional rules.

# linter:
#   rules:
#     - camel_case_types

# analyzer:
#   exclude:
#     - path/to/excluded/files/**

# For more information about the core and recommended set of lints, see
# https://dart.dev/go/core-lints

# For additional information about configuring this file, see
# https://dart.dev/guides/language/analysis-options

